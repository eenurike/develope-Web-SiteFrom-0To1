* {
  padding: 0;
  margin: 0;
}

.item {
  padding: 10px 0;
  background-color: lightseagreen;
  border: 1px solid black;
  border-radius: 5px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.item:nth-child(odd) {
  background-color: rgb(87, 241, 169);
}

/* CSS GRID */
.wrapper {
  /* Например нужно сделать глобальную разметку */
  height: 100vh;
  display: grid;
  grid-template-areas: 
    'header   header'
    'content  aside'
    'footer   footer'
  ;
  grid-template-columns: 300px 1fr;
  /* Типа чтоб первая колонка (aside) занимала 300px а вторая колонка на полную веселилась */
}

.header {
  grid-area: header;
  /* Называем нашу арею */
}

.aside {
  grid-area: aside;
}

.content {
  grid-area: content;
}

.footer {
  grid-area: footer;
}


.box {
  display: grid;
  gap: 10px;
  grid-gap: 10px;
  /* Тоже самое что и просто gap */
  grid-template-columns: 200px 300px 250px;
  /* То есть допустим нам нужно три колонки, вот так они создаются, и конечно же можно это все звписать в % */
  grid-template-columns: 25% 25% 25% 25%;
  /* % используются редко. Тут засчет межколоночных отступов появился горизонтальный скрол, 
  а фракции учитывают это все без горизонтального скрола */
  grid-template-columns: 1fr 1fr 1fr;
  /* Такое значение возможно только в grid, тоесть одна фракция, то есть если одна фракция, то элемент займет все пространство
  которое ей позволяет (100%), если по две фракции то занимает по 50% */
  grid-template-columns: repeat(4, 1fr);
  /* Тоже самое только короткой записью */
  grid-template-columns: 300px 1fr 1fr;

  grid-template-rows: 200px;
  /* И первая строка элементов высотой будет в 200px */
  grid-template-rows: 200px 300px 80px;
  /* Но если в этих блоках будет много контента, то они естественно будут выходить за рамки особенно у 80px */
  grid-template-rows: 200px 300px minmax(80px, auto);
  /* То есть если было бы возможно то оно было бы 80px, а если нет то сколько есть контента, такая высота и будет */


  grid-template-rows: unset;
  height: 100vh;
  grid-template-columns: repeat(3, 1fr);
}

/* Позиционирование */

.item:nth-child(1) {
  grid-column: 2;
  /* ТО есть первый элемент встал в второй столбец, а второй элемент переместился на третий, а в первом столбце пусто */
}

.item:nth-child(2) {
  grid-column: 1;
  /* Но теперь второй эллемент так как стоял стоял в третем столбце, переместился на вторую строку в первый столбец,
  а первый и третий столбец на первой строке пучтуют, чтоб второй элемент поставить в первую строку на первый столбец то есть в начало */
  grid-row: 1;
}

.text {
  grid-column: 3;
  grid-row: 4;
  /* Блок с текстом переместили вконец, то есть на 4 строку и в третий столбец */
}

.item:nth-child(4) {
  /* grid-column: 1 / 3; */
  /* Четвертый элемент будет занимать две колонки, он считает по линиям, типа с первой линии по третью линию */
  /* grid-row: 2 / 4; */
  /* И теперь элемент занимает 2 строки, и положение от второй линии по четвертую.
  Это нужно для того чтоб вообще кординально менять местоположение + увеличивая его или уменьшая */

  grid-column: span 2;
  /* Span это не то что ты подумал! это обозночает что этот элемент увеличится на две ячейки то есть будет 
  занимать два столбца, от того места где он стоит */
  grid-row: span 2;
}


